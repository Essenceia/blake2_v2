.program data_wr

.define offset 0
.origin offset


.define PUBLIC CTRL_READY_PIN 19
.define PUBLIC BUS_CLK_PIN    28

; send data from rpi to hw, writes both ctrl and data bus 
; expected to be running at 2xBUS_CLK freq

; will use auto pulling from the tx fifo to write to the gpio
; if the fifo is empty pull should block
; -> when blocked the content of the X scratch should be written
;    this will deactivate the valid bit on the data transfer line

; write X scratch register content, will be read to the OSR during blocking
; -> set to all 0s 

; wait for ready 
; then read config and data from the fifo ( streamed from dma )
; if no data is available write then content of X scratch
data_init:
	set pins, 0
	set x, 0 [1]
	jmp offset+data_start
data_wr:
	out pins, 32
	jmp !OSRE offset+data_wr
	set pins, 0 [1]
.wrap_target
data_start:
	;wait 1 pin 0 
	;wait 0 gpio BUS_CLK_PIN; 
	pull noblock
	jmp offset+data_wr
.wrap

% c-sdk {
static inline void data_wr_program_init(PIO pio, uint sm, uint offset, float fdiv){
	uint i;
	uint32_t pindirs = 0;// out = 1, in = 0
	uint32_t pinmask = 0;
	pio_sm_config c = bus_clk_program_get_default_config(offset);

	// join fifo's for one large fifo since sm is tx only
	//sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_TX);

	// enable fifo autopull and set threashold (32)
	sm_config_set_out_shift(&c, true, true, 32);

	//set "out" instruction to cover the entire gpio range
	sm_config_set_out_pins(&c, 0, 32);

	// set "set" instruction base pin offset to ctrl bit to overcome the 
	// 5b wide wright limitation
	_Static_assert(CTRL_BASE_PIN+5 > CTRL_VALID_PIN);
	sm_config_set_set_pins(&c, CTRL_VALID_PIN, 3);

	// in base, used in wait
	sm_config_set_in_pins(&c, CTRL_READY_PIN);

	// set config
	pio_sm_init(pio, sm, offset, &c); 

	// enable pins, connect to pio
	for(i=DATA_BASE_PIN; i < DATA_BASE_PIN + DATA_W; i++){ // data
		pio_gpio_init(pio, i);
	}
	pindirs |= DATA_MASK << DATA_BASE_PIN;
	pinmask |= DATA_MASK << DATA_BASE_PIN;

	for(uint i=CTRL_DATA_BASE_PIN; i < CTRL_DATA_BASE_PIN + CTRL_DATA_W; i++){ // ctrl data
		pio_gpio_init(pio, i);
	}
	pinmask |= CTRL_DATA_MASK << CTRL_DATA_BASE_PIN;
	pindirs |= CTRL_DATA_MASK << CTRL_DATA_BASE_PIN;

	// no need to set pio function for input pins
	gpio_init(CTRL_READY_PIN);
	gpio_set_dir(CTRL_READY_PIN, GPIO_IN);
	 
	pinmask |= (uint32_t)0x1 << CTRL_READY_PIN;

	pio_sm_set_pindirs_with_mask(pio, sm, pindirs, pinmask); 
	
	// set clk freq 
	pio_sm_set_clkdiv(pio, sm, fdiv);

	// clear fifo's
	pio_sm_clear_fifos(pio, sm);

}
%}

